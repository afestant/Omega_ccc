#if !(defined(__CLING__)  || defined(__CINT__)) || defined(__ROOTCLING__) || defined(__ROOTCINT__)
#include "AliGenPythia.h"
#include "AliDecayerPythia8.h"
#include "AliGenParam.h"
#include "AliGenerator.h"
#include "AliRunLoader.h"
#include "AliRun.h"
#include "AliStack.h"
#endif

void testKine(){
    
    
    gSystem->Load("libpythia6");
    
    TH1D *htau=new TH1D("hLambdaLifeTime","hLambdaLifeTime;#tau (s x 10^{-10})",100,0.,10.);
    
    // open galice.root
    AliRunLoader *rl = AliRunLoader::Open("galice.root",AliConfig::GetDefaultEventFolderName(), "read");
    if (rl == 0x0)
        cout<<"Can not instantiate the Run Loader"<<endl;
    cout<<"Run Loader"<<endl;
    
    // Load Kinematics
    rl->LoadKinematics();
    
    // Get maximum number of events
    Int_t maxevent =  rl->GetNumberOfEvents();
    cout<<"Number of events "<<maxevent<<endl;
    Int_t nomegap=0;
    Int_t nomegam=0;
    Int_t nlambda=0;
    Int_t nantilambda=0;
    Int_t npions=0;
    Int_t nprotons=0;
    Int_t nkaons=0;
    Int_t nomegac=0;
    Int_t nomegacc=0;
    Int_t nomegaccc=0;
    
    // Event loop
    for(Int_t iEvent=0; iEvent<maxevent; iEvent++){
        
        //Load Event
        rl->GetEvent(iEvent);
        cout << " ======> Event " << iEvent << "  "<<rl->GetEventNumber() <<endl ;
        
        // Call kinematic stack
        AliStack *sta=rl->Stack();
        
        cout << "# tracks in runloader " << sta->GetNtrack() << endl;  // Number of all generated particles by the event generator + particles (secondaries) generated by GEANT
        cout << " # primaries in runloader " << sta->GetNprimary() << endl;// Number of all generated particles by the event generator
        
        
        // Loop only on particles generated (no secondaries)
        for (Int_t  iprim=0; iprim<sta->GetNprimary() ; iprim++)
        {
            TParticle * primary=sta->Particle(iprim);
            
            //Float_t phi = primary->Phi()*TMath::RadToDeg();
            
            //if (sta->IsPhysicalPrimary(iprim))
            // {
            
            Int_t motherindex= primary->GetFirstMother();
            double eta = primary->Eta();
            double pT = primary->Pt();
            double p = primary->P();
            double T = primary->T();
            double rho = primary->Rho();
            double phi = primary->Phi();
            Int_t PDG = primary->GetPdgCode();
            int charge = (TDatabasePDG::Instance()->GetParticle(primary->GetPdgCode())->Charge())/3;
            double vx = primary->Vx();
            double vy = primary->Vy();
            double vz = primary->Vz();
            double mass = primary->GetMass();
            double E = primary->Energy();
            
            if(PDG==3334){nomegam++;}
            if(PDG==-3334){nomegap++;}
            if(PDG==3122){nlambda++;}
            if(PDG==-3122){nantilambda++;}
            
            if(TMath::Abs(PDG)==211){npions++;}
            if(TMath::Abs(PDG)==2212){nprotons++;}
            if(TMath::Abs(PDG)==321){nkaons++;}
            if(TMath::Abs(PDG)==4332){nomegac++;}
            if(TMath::Abs(PDG)==4432){nomegacc++;}
            if(TMath::Abs(PDG)==4444){nomegaccc++;}
            
            /*if(TMath::Abs(PDG)==3122){
             Double_t gamma=E/mass;
             TParticle *dau=sta->Particle(primary->GetDaughter(0));
             double Td = dau->T();
             double rhod = dau->Rho();
             double beta=((rhod-rho)*0.01)/(Td-T)/(2.99792458e8);
             Double_t gammacheck=1./TMath::Sqrt(1.-beta*beta);
             Double_t tau0=1.e10*Td/gamma;
             Printf("Mother:   p=%+3.4e mass=%+3.4e gamma     =%+3.4e L=%+3.4e T=%+3.4e",p, mass, gamma, rho, T);
             Printf("Daughter: p=%+3.4e mass=%+3.4e gammacheck=%+3.4e L=%+3.4e T=%+3.4e beta=%+3.4e",dau->P(), dau->GetMass(), gammacheck, rhod, Td, beta);
             htau->Fill(tau0);
             }*/
            
            //if(primary->GetStatusCode()<=0) continue;
            printf("%20s %5d %+5.3e %+5.3e %+5.3e %+5.3e %5d %+5.3e %+5.3e %+5.3e %+5.3e %+5.3e %5d mother %5d\n",primary->GetName(),iprim,p,T,pT,eta,charge,phi,vx,vy,vz,mass,PDG,motherindex);
            
            
            //}
        }
        
    }
    Printf("number of generated Omegac = %d Omegacc = %d Omegaccc = %d pions =%d protons =%d kaons = %d Omega- = %d Omega+ = %d Lambda = %d LambdaBar = %d",nomegac,nomegacc,nomegaccc,npions,nprotons,nkaons,nomegam, nomegap, nlambda, nantilambda);
    //htau->Scale(1./htau->Integral());
    htau->Draw();
    TF1 *fit=new TF1("fitFunc","[0]*TMath::Exp(-x/[1])",0.0001,5.);
    fit->SetParameter(0,200.);
    fit->SetParameter(1,2.6);
    htau->Fit(fit);
}

